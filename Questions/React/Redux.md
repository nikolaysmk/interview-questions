#redux

# Три принципа


`Action` -> `Dispatcher` -> `Reducer` -> `Store`

Redux можно описать в трех фундаментальных принципах:
- Единый источник истины
- Состояние доступно только для чтения
-  Изменения вносятся с помощью чистых функций (Reducer)


```js
type State = any
type Action = Object
type Reducer<S, A> = (state: S, action: A) => S

type BaseDispatch = (a: Action) => Action
type Dispatch = (a: Action | AsyncAction) => any

type MiddlewareAPI = { dispatch: Dispatch, getState: () => State }
type Middleware = (api: MiddlewareAPI) => (next: Dispatch) => Dispatch


type Store = {  
	dispatch: Dispatch  
	getState: () => State  
	subscribe: (listener: () => void) => () => void  
	replaceReducer: (reducer: Reducer) => void  
}
	
type StoreCreator = (reducer: Reducer, preloadedState: ?State) => Store

type StoreEnhancer = (next: StoreCreator) => StoreCreator
```

_**Store**_ — это состояние веб-компонента, которое хранит в себе всю информацию (или ту которую вы решили сохранить в него). В дальнейшем стор будет доступен из любого компонента вашего приложения.

_**Action**_ — действие, описывает что нужно сделать. Согласно принципам функционального программирования, мы не можем изменять объект напрямую, поэтому нам нужны экшены, чтобы передать их в диспатчер и «сказать», что нужно сделать.

_**Dispatcher**_ — сообщает хранилищу о каком-то действии (action) и передает ему обновленную информацию.

**Reducer** - это чистая функция, которая принимает предыдущее состояние и действие в качестве аргументов, и возвращает новое состояние в соответствии с правилами обработки действия¹. Reducer отвечает за обновление части стора Redux, связанной с определенным доменом или срезом данных².
- Reducer должен быть детерминированным, то есть при одинаковых аргументах всегда возвращать одинаковый результат.
- Reducer не должен мутировать предыдущее состояние, а создавать новый объект или массив с помощью оператора расширения (...), Object.assign или других иммутабельных операций.
- Reducer не должен выполнять побочные эффекты, такие как вызовы API, манипуляции с DOM или генерация случайных значений. Это должно делаться в middleware или action creator-ах.
- Reducer может быть разбит на более мелкие функции, которые обрабатывают отдельные части состояния или отдельные типы действий. Это называется reducer composition и позволяет повторно использовать и тестировать логику reducer-ов.
- Reducer может использовать switch, if-else, объект с функциями или любой другой способ для определения, какое действие обрабатывать и как его обработать³.




Основные методы для работы со store

-   _store.dispatch()_ — диспатч какого-либо экшена
-   _store.getState()_ — получение данных, которые хранятся в store
-   _store.subscribe()_ — подписка на изменения store.

-   useDispatch() — замена для mapDispatchToProps(). Этот хук возвращает dispatch метод. С его помощью мы потом можем диспатчить нужные экшены.
-   useSelector() — аналог mapStateToProps() — Этот хук принимает колбэк, который в качестве аргумента принимает текущий state. Вы можете вернуть весь state или какие-то определенные данные из него.
-   useStore() — этот хук возвращает ссылку на тот же state, который был передан в <Provider>. В документации редакса говорится о том, что лучше этот хук не использовать часто, а лучше пользоваться useSelector()

