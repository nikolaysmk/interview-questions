Алгоритм бинарного поиска широко используется в программировании для нахождения значения в отсортированных массивах. В этом документе мы рассмотрим, как этот алгоритм работает на примере JavaScript.

## Как работает алгоритм бинарного поиска?

Алгоритм бинарного поиска работает следующим образом:

1.  Определить левую и правую границы поиска. В начале поиска левая граница равна 0, а правая граница равна длине массива минус 1.
2.  Вычислить средний индекс массива путем нахождения среднего значения левой и правой границы и округления его в меньшую сторону до целого числа.
3.  Сравнить значение в средней позиции с искомым значением. Если они равны, то поиск завершен.
4.  Если искомое значение меньше значения в средней позиции, то продолжить поиск в левой половине массива, установив правую границу на позицию среднего элемента минус 1.
5.  Если искомое значение больше значения в средней позиции, то продолжить поиск в правой половине массива, установив левую границу на позицию среднего элемента плюс 1.
6.  Если левая граница больше правой границы, то искомое значение отсутствует в массиве.

## Реализация алгоритма бинарного поиска на JavaScript

Вот как реализовать алгоритм бинарного поиска на JavaScript:

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * Time O(log(N)) | Space O(1)
 * @return {number}
 */
var search = function (nums, target) {
    let [left, right] = [0, nums.length - 1];

    while (left <= right) {
        const mid = (left + right) >> 1;
        const guess = nums[mid];

        const isTarget = guess === target;
        if (isTarget) return mid;

        const isTargetGreater = guess < target;
        if (isTargetGreater) left = mid + 1;

        const isTargetLess = target < guess;
        if (isTargetLess) right = mid - 1;
    }

    return -1;
};

```

Здесь мы определяем функцию `search`, которая принимает два параметра: массив чисел `nums` и искомое значение `target`. Внутри функции мы инициализируем переменные `left` и `right`, которые представляют левую и правую границы поиска соответственно.

Затем мы начинаем цикл `while`, который выполняется до тех пор, пока левая граница не станет больше правой. Внутри цикла мы вычисляем средний индекс массива `mid` и значение элемента `guess` по этому индексу.

Затем мы проверяем, равно ли значение `guess` искомому значению `target`. Если да, мы возвращаем значение `mid`, что означает, что мы нашли искомое значение в массиве.

Если значение `guess` меньше искомого значения `target`, мы устанавливаем левую границу на позицию среднего элемента плюс 1. Если значение `guess` больше искомого значения `target`, мы устанавливаем правую границу на позицию среднего элемента минус 1.

Если мы не нашли искомое значение в массиве, цикл завершается, и мы возвращаем -1.

## Временная сложность алгоритма бинарного поиска

Временная сложность алгоритма бинарного поиска составляет O(log(N)), где N - это размер массива. Это означает, что время поиска увеличивается логарифмически при увеличении размера массива.

## Пространственная сложность алгоритма бинарного поиска

Пространственная сложность алгоритма бинарного поиска составляет O(1), что означает, что алгоритм использует постоянное количество дополнительной памяти, независимо от размера массива.

Надеемся, что этот документ поможет вам лучше понять, как работает алгоритм бинарного поиска и как его можно реализовать на JavaScript. Если у вас есть какие-либо вопросы или комментарии, пожалуйста, не стесняйтесь написать нам.